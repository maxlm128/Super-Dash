package main;

public class ExtSpike extends Entity {

	Screen screen;
	Menu menu;
	ExtSpikeHead extSpikeHead;
	int length;
	boolean isExtending = true;
	boolean canDestroy;
	int extentionTime = 100;
	int spikeTimer;

//initializes the references and the color
	public ExtSpike(char pRotation, Screen pScreen, Menu pMenu) {
		rotation = pRotation;
		screen = pScreen;
		menu = pMenu;
		color = 4;
		extSpikeHead = new ExtSpikeHead(coordsXEntity,coordsYEntity);
	}

// checks for every case if something is in front of the spike
	private boolean isSomethingInFront(char pContent) {
		switch (rotation) {
		case 'd':
			return Map.map[extSpikeHead.coordsXEntity + 1][extSpikeHead.coordsXEntity] != pContent;
		case 's':
			return Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity + 1] == pContent;
		case 'a':
			return Map.map[extSpikeHead.coordsXEntity - 1][extSpikeHead.coordsXEntity] == pContent;
		case 'w':
			return Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity - 1] == pContent;
		}
		return true;
	}

	private Entity whatIsInFront() {
		switch (rotation) {
		case 'd':
			return Map.entityMap[extSpikeHead.coordsXEntity + 1][extSpikeHead.coordsXEntity];
		case 's':
			return Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity + 1];
		case 'a':
			return Map.entityMap[extSpikeHead.coordsXEntity - 1][extSpikeHead.coordsXEntity];
		case 'w':
			return Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity - 1];
		}
		return null;
	}

//a method to let the spike extend and retract alternately with a extention time between it
	
	public void spikeTimer() {
		if (whatIsInFront() instanceof Player || whatIsInFront() instanceof Player
				|| whatIsInFront() instanceof Player || whatIsInFront() instanceof Player) {
			menu.executeDeathAnimation();
		}
		if (isExtending && isSomethingInFront(' ')) {
			extendSpike();
		} else if (isExtending && spikeTimer < extentionTime) {
			spikeTimer++;
		} else if (isExtending) {
			isExtending = false;
			spikeTimer = 0;
		}
		if (!isExtending && (extSpikeHead.coordsXEntity != coordsXEntity || extSpikeHead.coordsXEntity != coordsYEntity)) {
			retractSpike();
		} else if (!isExtending && spikeTimer < extentionTime) {
			spikeTimer++;
		} else if (!isExtending) {
			isExtending = true;
			spikeTimer = 0;
		}
	}

//moves the current head location by one away from the entity position
	private void extendSpike() {
		switch (rotation) {
		case 'd':
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = '-';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = null;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, extSpikeHead.color);
			extSpikeHead.coordsXEntity++;
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = '>';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = extSpikeHead;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, color);
			break;
		case 's':
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = '|';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = null;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, extSpikeHead.color);
			extSpikeHead.coordsXEntity++;
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = 'v';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = extSpikeHead;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, color);
			break;
		case 'a':
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = '-';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = null;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, extSpikeHead.color);
			extSpikeHead.coordsXEntity--;
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = '<';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = extSpikeHead;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, color);
			break;
		case 'w':
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = '|';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = null;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, extSpikeHead.color);
			extSpikeHead.coordsXEntity--;
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = '^';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = extSpikeHead;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, color);
			break;
		}
	}

//moves the current head location by one to the entity position
	private void retractSpike() {
		switch (rotation) {
		case 'd':
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = ' ';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = null;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, color);
			extSpikeHead.coordsXEntity--;
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = '>';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = extSpikeHead;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, color);
			break;
		case 's':
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = ' ';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = null;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, color);
			extSpikeHead.coordsXEntity--;
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = 'v';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = extSpikeHead;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, color);
			break;
		case 'a':
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = ' ';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = null;
			screen.print(extSpikeHead.coordsXEntity, extSpikeHead.coordsXEntity, color);
			extSpikeHead.coordsXEntity++;
			Map.map[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = '<';
			Map.entityMap[extSpikeHead.coordsXEntity][extSpikeHead.coordsXEntity] = extSpikeHead;
			screen.print(coordsXSpikeHead, extSpikeHead.coordsXEntity, color);
			break;
		case 'w':
			Map.map[coordsXSpikeHead][extSpikeHead.coordsXEntity] = ' ';
			Map.entityMap[coordsXSpikeHead][extSpikeHead.coordsXEntity] = null;
			screen.print(coordsXSpikeHead, extSpikeHead.coordsXEntity, color);
			extSpikeHead.coordsXEntity++;
			Map.map[coordsXSpikeHead][extSpikeHead.coordsXEntity] = '^';
			Map.entityMap[coordsXSpikeHead][extSpikeHead.coordsXEntity] = extSpikeHead;
			screen.print(coordsXSpikeHead, extSpikeHead.coordsXEntity, color);
			break;
		}
	}

	public void inizializeCoordsSpikeHead() {
		extSpikeHead.coordsXEntity = coordsXEntity;
		extSpikeHead.coordsXEntity = coordsYEntity;
	}
}
